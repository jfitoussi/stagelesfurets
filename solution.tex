\chapter{Solution}

\section{Eclipse : Sirius}
Les premiers début du développement d’un modele pour Eclipse Sirius fut très fastidieux, après avoir passé un bout de temps sur le tutorial présent sur le site je me suis confronté a un manque d’autres exemples me permettant de vraiment prendre en main Sirius. Le manque d'information à été combler par l'équipe en charge du développement de Sirius. Cependant les démarches pour disposer d'une formation dans leur locaux à Nantes a pris trop de temps pour differentes raisons et nous avons du mettre de coté cette partie de la solution.

\section{Application Web}
Ma premier démarche a été de trouver une bibliothèque Javascript capable de generer un graphe orienté cyclique. Google m’a diriger vers une question similaire sur stackoverflow. J’ai bénéficier d'un comparatif complet des existent sur le net, avec leur avantages et inconvénient. Mon choix s’est porter sur cytoscape.js. Cytoscape avait l’avantage de réaliser rapidement un graphe correspondant à mes besoin depuis un fichier JSON. Il offre de plus une integration avec jQuery et/ou Angular pour la manipulation du DOM. Il est sous licence GPL ce qui faisait partie des impératifs du projet. Enfin Cytoscape propose par defaut une dizaine de layout utilisable pour explorer de différentes manière le graphe.
\clearpage
\section{Développement de l'outil}

\subsection{Tableau Json}
La première chose pour pouvoir exploiter un affichage du graphe des champs du formulaire avec Cytoscape est de générer un fichier Json. Le fichier contenant une liste d'objet représentant soit un noeud soit une arête. 
\begin{lstlisting}
elements: [
      { data: { id: 'foo' }, group: "nodes" },
      { data: { id: 'bar' }, group: "nodes" },
      { data: { id: 'baz', source: 'foo', target: 'bar' }, group: "edges" }
    ]
\end{lstlisting}
En se servant de la bibliothèque de Google Gson qui permet de transformer un objet Java en objet Javascript, il a été necessaire de créer des classes correspondant aux critères de Cytoscape. Il a fallu par la suite générer un fichier pour chaque tunnel au format Json contenant chaque champs avec les données qui lui sont propres et les dépendances sous formes d'arètes.

\subsection{Génération du graphe}
La logique par la suite était de servir les fichiers Json de façon asynchrone à la demande d'affichage du graphe d'un des tunnels de LesFurets.com. Pour cela la solution vers laquelle je me suis tourner était la manipulation du DOM à l'aide de AngularJS. Cytoscape permet à l'aide de closure de modifier le graph qu'en cas de modifications défini dans le "controller" AngularJS. 
\vspace{0.2in}
\begin{figure}[!ht]
\center
\includegraphics[width=15cm]{outil/buttons-tunnels.png}
\caption{Choix du tunnel}
\end{figure}
Ainsi à chaque demande du graphe d'un tunnel à l'aide d'un des bouttons de l'interface on demande si le tableau Json existe. Si il existe on trace le graphe sinon on fait un appel au serveur, une fois le fichier récu on lance le calcule du graphe. Si il y a une attente, on affichera un élégant loader invitant l'utilisateur à prendre son mal en patience.

\subsection{Zoomer, Déplacer les éléments, Se déplacer}
Une fois le graphe affichée il est apparu essentiel de pouvoir laisser l’utilisateur zoomer, se déplacer dans le graphe et déplacer les éléments du graphe. A l'aide de la documentation de l'API, j'ai défini des fonctions de glisser déposer pour déplacer les éléments ainsi que pour déplacer tout le graphe. Enfin pour les fonctions de zoom nous avons passer tous le graphe en position relative.
\clearpage
\subsection{Layout du graphe}
Cytoscape dispose d'un système pour permettre aux développeur de définir leur layout. Un layout n'étant qu'un ensemble de règles défini pour afficher les noeuds et arêtes sous forme de graphe.
\begin{lstlisting}[caption=Exemple d'un layout traçant le graphe sous forme de cercle]
var layoutCircle = {
  name: 'circle',
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  radius: undefined, // the radius of the circle
  startAngle: 3/2 * Math.PI, // the position of the first node
  counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};
\end{lstlisting}
Enfin on laissera la possibilité à l'utilisateur de choisir le layout dont il aura besoin.
\begin{figure}[!h]
\centering
\includegraphics[height=10cm]{outil/layout-circle.png}
\caption{Graphe tracé avec un layout "circle"}
\end{figure}

\subsection{Layout WireFrame}
On proposera un layout "wireframe" qui permettra d'afficher le graphe sous une forme similaire au formulaire proposer dans les tunnels du site. C'est a dire que chaque écran est poser à la suite l'un de l'autre avec, à la suite, verticalement, les champs du formulaire.

\subsection{Layout DAG}
On proposera aussi un layout "dag" qui affichera le graphe avec en evidence les cycles et les dependances plus fortes.

\subsection{Recherche d’un champs et autocompletion}
Pour pouvoir rendre l’outil plus user-friendly, j’ai decider de proposer aux utilisateur de pouvoir rechercher une question parmis les question proposer et ainsi pouvoir zoomer sur celle-ci sans avoir a les rechercher visuellement

\subsection{Champs du formulaire}
Dans un premier temps l’idée etait de pouvoir differencier les champs du formulaire et les faire ressembler aux champs du site

\subsection{Disposition du graph}
Par la suite il a fallu reprendre le graph pour le faire ressembler a un formulaire du site

\subsection{Modification des elements et des dependances}
Une fois le graph ressemblant au formulaire present sur le site il a fallu mettre en place une fonction de modifications des elements du graph. Et une fonction de modifications des dependances entre les champs.

\subsection{Modification du label du champs}
La premiere fonction était sans doute celle qui avait le moins d’incidence sur le formulaire. On peut juste changer le label afficher sur le formulaire

\subsection{Modification type du champs}
On peut à l’aide d’une autocompletion avoir accés a tous les types de champs present sur le tunnel et modifier le type du champs sur lequel on est

\subsection{Suppression d’une dependance}
Il s’agit juste de mettre en evidence les champs touché par la suppression d’une dependances. Les dependances ne sont pas interdependantes.

\subsection{Sauvegarde etat du graph}
Une fois les fonctions de modifications mise en place il a paru evident qu’il a fallait pouvoir sauvegarder l’etat du graph modifié pour pouvoir l’envoyer par la suite.
La premiere approche simple était de pouvoir faire une capture d’ecran de l’etat du graph dans une resolution assez grande pouvoir voit toute les details du formulaire.
La seconde approche fut de sauvegarder un fichier JSON avec toutes les données modifié ainsi que les position des champs

\subsection{Charger un graph}
Une fois les graph sauvegardable il a fallu pouvoir les reafficher a l’aide d’un module d’import. Une balise input file et un recalcul du graph nous a permis d’implementer cette fonction rapidement

\subsection{Affichage des differences}
Une fois le graph importer nous avons voulu aussi proposer une visualisation des differences avec la version presente et une version importer.

\subsection{Not User-friendly}
Les furets mette leur site en production de maniere quotidienne, il nous a paru pertinent comme fonctionnalité de pouvoir affichage la presence de difference entre le graph en de la version du site en production et la version a mettre en production sans passer par l’interface graphique. Ainsi on proposera une liste au format texte des differences entre ces deux versions.

\section{Données Business}

\subsection{Récuperation des données}
Apres differentes discussion avec les equipes en charge de la conception de l’application nous avons decider de ne pas faire des appels SQL a chaque affichage du graph. L’entreprise etant en train de migrer les données sur cassandra toute intervention sur la base serait inutile.
Cependant des batches sont deja en place pour recuperer des informations a intervalles regulier, nous avons donc opter dans un premier par recuperer les informations a chaque fois que les batches fait leur jobs. Ainsi nous avions deja un traitement de l’information. Il nous a fallu quand meme definir quels informations recuperer et trouver une moyen de les superproser au graph. Nous avons decider de tracer le graph dans un premier temps et mettre en mecanisme en place an angular qui permet d’ajouter les données business a la demande l’utilisateur

\subsection{Affichage des données}
Une fois le traitement et la recuperation des données realisé nous avons decider de mettre ses données en evidence sous forme d'un indicateur allant du rouge au vert pour le taux d’abandon du formulaire, avec une affichage plus detaillé lors du clique. 